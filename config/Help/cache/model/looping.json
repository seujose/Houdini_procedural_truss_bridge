{"type": "root", "attrs": {"since": "15.0", "bestbet": "block"}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Looping in geometry networks"], "extent": [0, 33]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [64, 79], "body": [{"type": "vimeo_group", "body": [{"ext": null, "type": "vimeo", "indent": 0, "text": [" For each loop"], "role": "item", "extent": [79, 102], "body": [], "container": true, "attrs": {"id": "142494487"}}], "container": true, "role": "item_group"}, {"type": "vimeo_ref_group", "body": [{"ext": null, "type": "vimeo_ref", "indent": 0, "text": [" H15 Masterclass: Loops"], "role": "item", "extent": [122, 157], "body": [], "container": true, "attrs": {"id": "142534639"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["Normally, Houdini processes the nodes in a geometry network from top to bottom, feeding the output of each node into the input of the next node, down to the node with the display or render flag. However, there are times when it\u2019s useful to do ", {"type": "em", "text": ["looping"]}, ": running the same chain of nodes multiple times."], "extent": [177, 480]}, {"type": "para", "indent": 0, "text": ["There are three main uses for looping:"], "extent": [480, 520]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You want to ", {"scheme": null, "value": "#repeat", "type": "link", "text": ["process the input geometry over and over again"], "fullpath": "/model/looping#repeat", "fragment": "#repeat"}, "."], "extent": [520, 593], "body": [{"type": "para", "indent": 4, "text": ["For example, you might want to add multiple layers of noise, or create complex procedural geometry by extruding all faces multiple times."], "extent": [593, 736]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You want to ", {"scheme": null, "value": "#foreach", "type": "link", "text": ["process each piece of the input geometry"], "fullpath": "/model/looping#foreach", "fragment": "#foreach"}, "."], "extent": [736, 804], "body": [{"type": "para", "indent": 4, "text": ["For example, you might want to apply the same edits to each rock in some rubble."], "extent": [804, 890]}], "container": true}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["You want to ", {"scheme": null, "value": "#swisscheese", "type": "link", "text": ["process one geometry using each piece of another geometry"], "fullpath": "/model/looping#swisscheese", "fragment": "#swisscheese"}, "."], "extent": [890, 979], "body": [{"type": "para", "indent": 4, "text": ["The classic example of this is the ", {"type": "q", "text": ["Swiss cheese problem"]}, ": you want to loop over each sphere in the set of air bubbles and subtract it from a block of cheese."], "extent": [979, 1143]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The ", {"type": "q", "text": ["For Loop"]}, " and ", {"type": "q", "text": ["For Each Loop"]}, " tools in the network editor tab menu set up ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin"], "fullpath": "/nodes/sop/block_begin"}, " and ", {"scheme": "Node", "value": "/nodes/sop/block_end", "type": "link", "text": ["Block End"], "fullpath": "/nodes/sop/block_end"}, " nodes, where the nodes between the begin and end are looped."], "extent": [1143, 1355]}]}, {"level": 2, "id": "repeat", "container": true, "type": "h", "indent": 0, "text": ["Repetition"], "extent": [1355, 1381], "body": [{"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["In the network editor, open the ", {"keys": ["Tab"], "type": "keys", "text": null}, " menu and choose ", {"type": "q", "text": ["For loop"]}, "."], "extent": [1381, 1453], "body": [{"type": "para", "indent": 4, "text": ["The tool will create a ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin"], "fullpath": "/nodes/sop/block_begin"}, " and ", {"scheme": "Node", "value": "/nodes/sop/block_end", "type": "link", "text": ["Block End"], "fullpath": "/nodes/sop/block_end"}, " node wired together. The Block Begin has the ", {"type": "ui", "text": ["Method"]}, " parameter set to ", {"type": "q", "text": ["Fetch feedback"]}, ", meaning it will start each loop after the first with the output of the previous loop."], "extent": [1453, 1728]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Select the Block End node and set the ", {"type": "ui", "text": ["Iterations"]}, " parameter to the number of times you want the loop to run."], "extent": [1728, 1843], "body": [{"type": "warning_group", "body": [{"type": "warning", "indent": 4, "role": "item", "extent": [1843, 1856], "body": [{"type": "para", "indent": 8, "text": ["You should probably start with ", {"type": "em", "text": ["just 1 or 2 iterations at first"]}, " until you know the loop is working they way you want. It\u2019s possible to unintentionally create a loop that operates on all geometry ", {"type": "em", "text": ["and"]}, " creates new geometry in each loop, exponentially increasing the geometry size and cooking time. Note that if Houdini gets stuck in a long cook you can press ", {"keys": ["Esc"], "type": "keys", "text": null}, " to cancel the cook."], "extent": [1856, 2252]}], "container": true}], "container": true, "role": "item_group"}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Wire the geometry you want to process into the Block Begin."], "extent": [2252, 2315]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Wire the nodes to process the geometry between the Block Begin and Block End."], "extent": [2315, 2396]}], "container": true}, {"type": "para", "indent": 0, "text": ["In this example, we simply do two iterations of extruding and scaling every face of a box."], "extent": [2396, 2488]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [2488, 2494], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/model/loop_simple_network.jpg", "type": "link", "text": "", "fullpath": "/images/model/loop_simple_network.jpg"}], "extent": [2494, 2544]}], "container": true}, {"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [2544, 2550], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/model/loop_simple_result.jpg", "type": "link", "text": "", "fullpath": "/images/model/loop_simple_result.jpg"}], "extent": [2550, 2600]}], "container": true}], "container": true, "role": "item_group"}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [2600, 2606], "body": [{"type": "para", "indent": 4, "text": ["The point of this type of loop is that the output of one loop becomes the input for the next loops, so any geometry you create in the loop will ", {"type": "em", "text": ["accumulate"]}, ". If all you want is to apply the same nodes once to multiple copies, you want the ", {"scheme": "Node", "value": "/nodes/sop/copy", "type": "link", "text": ["Copy node"], "fullpath": "/nodes/sop/copy"}, "."], "extent": [2606, 2878]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "foreach", "container": true, "type": "h", "indent": 0, "text": ["Piecewise (for-each) looping"], "extent": [2878, 2923], "body": [{"type": "para", "indent": 0, "text": ["A ", {"type": "q", "text": ["piece"]}, " is usually defined as the primitives that have the same value of the ", {"type": "code", "text": ["piece"]}, " or ", {"type": "code", "text": ["name"]}, " attribute. Several tool such as ", {"scheme": null, "value": "/shelf/shatter", "type": "link", "text": ["Shatter"], "fullpath": "/shelf/shatter"}, " create this type of partition attribute for you. You can specify an attribute name other than ", {"type": "code", "text": ["piece"]}, " using the ", {"type": "ui", "text": ["Template attribute"]}, " parameter on the ", {"scheme": "Node", "value": "/nodes/sop/block_end", "type": "link", "text": ["Block End node"], "fullpath": "/nodes/sop/block_end"}, " (this parameter is only available when the Block Begin\u2019s input is connected)."], "extent": [2923, 3345]}, {"type": "para", "indent": 0, "text": ["If no template attribute exists, block will loop over each point or primitive."], "extent": [3345, 3425]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["In the network editor, open the ", {"keys": ["Tab"], "type": "keys", "text": null}, " menu and choose ", {"type": "q", "text": ["For Each Loop"]}, "."], "extent": [3425, 3501], "body": [{"type": "para", "indent": 4, "text": ["The tool will create a ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin"], "fullpath": "/nodes/sop/block_begin"}, " and ", {"scheme": "Node", "value": "/nodes/sop/block_end", "type": "link", "text": ["Block End"], "fullpath": "/nodes/sop/block_end"}, " node wired together. The Block Begin has the ", {"type": "ui", "text": ["Method"]}, " parameter set to ", {"type": "q", "text": ["Fetch piece"]}, ", meaning it will start each loop with a different piece of the input."], "extent": [3501, 3756]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Select the Block End node and set the ", {"type": "ui", "text": ["Template class"]}, " to the type of pieces you are iterating over (points or primitives/faces). This will usually be primitives."], "extent": [3756, 3924], "body": [{"type": "para", "indent": 4, "text": ["Note that you don\u2019t set the number of iterations\u2026 the loop will simply loop over each piece in the input."], "extent": [3924, 4037]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["In this example, we loop over the pieces of a shattered torus and apply ", {"scheme": "Node", "value": "/nodes/sop/mountain", "type": "link", "text": ["Mountain"], "fullpath": "/nodes/sop/mountain"}, " to each one individually."], "extent": [4037, 4165]}, {"type": "col_group", "body": [{"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [4165, 4171], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/model/loop_piecewise_network.jpg", "type": "link", "text": "", "fullpath": "/images/model/loop_piecewise_network.jpg"}], "extent": [4171, 4224]}], "container": true}, {"ext": null, "type": "col", "indent": 0, "role": "item", "extent": [4224, 4230], "body": [{"type": "para", "indent": 4, "text": [{"scheme": "Image", "value": "/images/model/loop_piecewise_result.jpg", "type": "link", "text": "", "fullpath": "/images/model/loop_piecewise_result.jpg"}], "extent": [4230, 4284]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "swisscheese", "container": true, "type": "h", "indent": 0, "text": ["Multiple inputs"], "extent": [4284, 4320], "body": [{"type": "para", "indent": 0, "text": ["A loop can have more than one Block Begin node. So, for example, one branch of the network will get its input ", {"type": "em", "text": ["piecewise"]}, " and another branch will be simple repetition accumulating the result of using the pieces."], "extent": [4320, 4534]}, {"type": "para", "indent": 0, "text": ["The classic example of this type of loop is making Swiss cheese: use simple repetition to accumulate the results of processing one input geometry (the cheese block) by looping over pieces from a second input geometry (the air bubbles)."], "extent": [4534, 4771]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["In the network editor, open the ", {"keys": ["Tab"], "type": "keys", "text": null}, " menu and choose ", {"type": "q", "text": ["For loop"]}, "."], "extent": [4771, 4842], "body": [{"type": "para", "indent": 4, "text": ["This loop branch will do the work of accumulating the changes to the cheese block."], "extent": [4842, 4930]}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Create another ", {"scheme": "Node", "value": "/nodes/sop/block_begin", "type": "link", "text": ["Block Begin"], "fullpath": "/nodes/sop/block_begin"}, " node."], "extent": [4930, 4989], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["Set the ", {"type": "ui", "text": ["Method"]}, " parameter to ", {"type": "q", "text": ["Fetch piece"]}, "."], "extent": [4989, 5043]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["Set the ", {"type": "ui", "text": ["Block path"]}, " parameter to the Block End of the existing loop. You can use the ", {"scheme": "Icon", "value": "BUTTONS/chooser_node", "type": "link", "text": "", "fullpath": "/model/BUTTONS/chooser_node"}, " node chooser button next to the parameter, or drag the Block End from the network editor onto the parameter in the parameter editor."], "extent": [5043, 5299]}], "container": true}, {"type": "para", "indent": 4, "text": ["This loop branch will do the work of fetching each bubble from the bubble geometry."], "extent": [5299, 5388]}], "container": true}], "container": true}, {"type": "para", "indent": 0, "text": ["The following shows an example network for making Swiss cheese using the two loop branches:"], "extent": [5388, 5481]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [{"scheme": "Image", "value": "/images/model/swiss_cheese_network.svg", "type": "link", "text": "", "fullpath": "/images/model/swiss_cheese_network.svg"}, " ", {"scheme": "Image", "value": "/images/model/swiss_cheese_result.jpg", "type": "link", "text": "", "fullpath": "/images/model/swiss_cheese_result.jpg"}], "role": "item", "extent": [5481, 5580], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["1"], "extent": [5580, 5587], "body": [{"type": "para", "indent": 8, "text": ["We start with a box representing the block of cheese, and turn it into a VDB."], "extent": [5619, 5705]}], "container": true, "attrs": {"display": "green compact"}}, {"type": "dt", "indent": 4, "text": ["2"], "extent": [5705, 5712], "body": [{"type": "para", "indent": 8, "text": ["We scatter some points in the box and copy spheres onto them to represent air bubbles."], "extent": [5743, 5838]}], "container": true, "attrs": {"display": "blue compact"}}, {"type": "dt", "indent": 4, "text": ["3"], "extent": [5838, 5845], "body": [{"type": "para", "indent": 8, "text": ["The first Block Begin is a simple repetition that takes the VDB ", {"type": "q", "text": ["cheese block"]}, " as input and accumulates the changes inside the loop."], "extent": [5878, 6024]}], "container": true, "attrs": {"display": "yellow compact"}}, {"type": "dt", "indent": 4, "text": ["4"], "extent": [6024, 6031], "body": [{"type": "para", "indent": 8, "text": ["The second Block Begin is a ", {"type": "q", "text": ["Fetch Piece"]}, " that takes the ", {"type": "q", "text": ["air bubbles"]}, " as input and loops over each primitive sphere. Under it we turn the sphere into a VDB."], "extent": [6061, 6236]}, {"type": "para", "indent": 8, "text": ["We wire the ", {"type": "q", "text": ["cheese block"]}, " VDB into the ", {"type": "q", "text": ["air bubble"]}, " VDB\u2019s second input (5) to make it copy the resolution settings from the cheese block."], "extent": [6236, 6388]}], "container": true, "attrs": {"display": "red compact"}}, {"type": "dt", "indent": 4, "text": ["3"], "extent": [6388, 6395], "body": [{"type": "para", "indent": 8, "text": ["Inside the loop we use a ", {"scheme": "Node", "value": "/nodes/sop/vdbcombine", "type": "link", "text": ["VDB Combine"], "fullpath": "/nodes/sop/vdbcombine"}, " to subtract the VDB sphere from the cheese block."], "extent": [6433, 6552]}], "container": true, "attrs": {"display": "yellow compact"}}], "container": true}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "metadata", "container": true, "type": "h", "indent": 0, "text": ["How to get information about the current loop"], "extent": [6552, 6615], "body": [{"type": "para", "indent": 0, "text": ["Sometimes you need the current loop, or the current piece number, in an expression on one of the nodes in the loop. You can get this information with a ", {"type": "q", "text": ["Fetch metadata"]}, " Block Begin node."], "extent": [6615, 6804]}, {"type": "ord_group", "body": [{"blevel": 2, "type": "ord", "indent": 0, "text": ["Set up a looping block using the instructions above."], "extent": [6804, 6860]}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["Select the Block Begin node. In the parameter editor, click ", {"type": "ui", "text": ["Create Meta Import Node"]}, "."], "extent": [6860, 6952], "body": [{"type": "para", "indent": 4, "text": ["This button adds a second Block Begin node to the side of the existing one. This node is set up to generate an empty geometry with some detail attributes."], "extent": [6952, 7116]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["numiterations"]}], "extent": [7116, 7137], "body": [{"type": "para", "indent": 8, "text": ["The expected total number of iterations, taking into account the ", {"type": "ui", "text": ["Max Iterations"]}, " and ", {"type": "ui", "text": ["Single Pass"]}, " parameters on the Block End."], "extent": [7137, 7279]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["iteration"]}], "extent": [7279, 7296], "body": [{"type": "para", "indent": 8, "text": ["The current iteration number, always starting at ", {"type": "code", "text": ["0"]}, " and increasing by 1 each loop."], "extent": [7296, 7389]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["value"]}], "extent": [7389, 7402], "body": [{"type": "para", "indent": 8, "text": ["In piece-wise loops, this is the current value of the attribute, for example the ", {"type": "code", "text": ["piece"]}, " integer or ", {"type": "code", "text": ["name"]}, " string (or the current point or primitive number if there is no attribute)."], "extent": [7402, 7602]}, {"type": "para", "indent": 8, "text": ["In simple repetition loops, this is a floating point value starting at the Block End\u2019s ", {"type": "ui", "text": ["Start value"]}, " and increasing by ", {"type": "ui", "text": ["Increment"]}, " each loop."], "extent": [7602, 7761]}], "container": true}, {"type": "dt", "indent": 4, "text": [{"type": "code", "text": ["ivalue"]}], "extent": [7761, 7775], "body": [{"type": "para", "indent": 8, "text": ["In simple repetition, this is an integer version of ", {"type": "code", "text": ["value"]}, ". This can be useful if the value is naturally integer (for example, start at ", {"type": "code", "text": ["1"]}, " and increment by ", {"type": "code", "text": ["2"]}, ") and/or if values may be over 24 million (where floating point numbers lose precision)."], "extent": [7775, 8034]}], "container": true}], "container": true}], "container": true}, {"blevel": 2, "type": "ord", "indent": 0, "text": ["To grab the value of these attributes in a node inside the loop\u2026"], "extent": [8034, 8104], "body": [{"type": "bullet_group", "body": [{"blevel": 6, "type": "bullet", "indent": 4, "text": ["In a Houdini expression, use the ", {"scheme": "Exp", "value": "/expressions/detail", "type": "link", "text": "", "fallback_text": "detail()", "fullpath": "/expressions/detail"}, " expression function."], "extent": [8104, 8178], "body": [{"type": "para", "indent": 8, "text": ["For example:"], "extent": [8178, 8200]}, {"lang": null, "type": "pre", "indent": 8, "text": ["\n        detail(\"../block_begin2\", \"iteration\", 0)\n        "], "extent": [8200, 8274]}], "container": true}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["In an ", {"scheme": "Node", "value": "/nodes/sop/attribwrangle", "type": "link", "text": ["Attribute wrangle"], "fullpath": "/nodes/sop/attribwrangle"}, ", use the ", {"scheme": "Vex", "value": "/vex/functions/detail", "type": "link", "text": "", "fallback_text": "detail()", "fullpath": "/vex/functions/detail"}, " VEX function."], "extent": [8274, 8367]}, {"blevel": 6, "type": "bullet", "indent": 4, "text": ["In Python, use ", {"scheme": "Hom", "value": "/hom/hou/Geometry#attribValue", "type": "link", "text": "", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "fragment": "#attribValue"}, ":"], "extent": [8367, 8425], "body": [{"lang": "python", "type": "pre", "indent": 8, "text": ["\n        node(\"../block_begin2\").geometry().attribValue(\"iteration\")\n        "], "extent": [8425, 8534]}], "container": true}], "container": true}], "container": true}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Stop condition"], "extent": [8534, 8557], "body": [{"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Iterations"]}, " and ", {"type": "ui", "text": ["Max Iterations"]}, " are computed before the loop starts so can be used to stop a loop early using results from the loop."], "extent": [8557, 8702]}, {"type": "para", "indent": 0, "text": ["Making the ", {"type": "ui", "text": ["Stop condition"]}, " parameter on the Block End node evaluate to ", {"type": "code", "text": ["1"]}, " before an iteration will stop the loop. This lets you write an expression that tests certain conditions. For example, you could stop looping if the number of polygons in a feedback loop passes a certain threshold."], "extent": [8702, 8995]}, {"type": "para", "indent": 0, "text": ["Note that this condition is evaluated ", {"type": "strong", "text": ["before"]}, " the loop is processed."], "extent": [8995, 9066]}, {"type": "para", "indent": 0, "text": ["Note this is not yet supported in compiled blocks."], "extent": [9066, 9119]}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Debugging and testing loops"], "extent": [9119, 9153], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["You can step through the iterations of the loop by setting the ", {"type": "ui", "text": ["Max iterations"]}, " parameter on the Block End node. For example, start it at ", {"type": "code", "text": ["1"]}, " and increase to see the results of each loop."], "extent": [9153, 9347]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["In piecewise loops, you can see the output of an individual piece/iteration using the ", {"type": "ui", "text": ["Single pass"]}, " parameter on the Block End node. "], "extent": [9347, 9487]}], "container": true}]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Tips"], "extent": [9487, 9498], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["This node does not allow specifying pieces using groups. Because groups are not necessarily disjoint, it is very slow to translate them into pieces. If your geometry uses groups to specify the pieces, you can create an attribute from the groups using the ", {"scheme": "Node", "value": "/nodes/sop/name", "type": "link", "text": ["Name node"], "fullpath": "/nodes/sop/name"}, "'s ", {"type": "q", "text": ["Name from Groups"]}, " function, then split by the created attribute."], "extent": [9498, 9851]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["The color of the blob surrounding the nodes in a loop comes from the color of the Block Begin and Block End nodes. Change the color of one of these nodes to change the color of the blob."], "extent": [9851, 10041]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["To hide or show the blobs, click the ", {"scheme": "Icon", "value": "BUTTONS/displayoptions", "type": "link", "text": "", "fullpath": "/model/BUTTONS/displayoptions"}, " Display Options button or press ", {"keys": ["D"], "type": "keys", "text": null}, " in the network editor. In the network display options window, click the ", {"type": "ui", "text": ["Network View \u25b8 Display"]}, " sub-tab and turn ", {"type": "ui", "text": ["Display complex hulls"]}, " on or off."], "extent": [10041, 10302]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Currently only nodes between Block Begin and Block End nodes are included in the blob. Unfortunately the blob does wrap around nodes that are included in the loop because of channel reference dependencies. This is a limitation of the current implementation."], "extent": [10302, 10564]}], "container": true}]}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [10564, 10573], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": null, "value": "/shade/looping", "type": "link", "text": ["Looping in VOPs"], "fullpath": "/shade/looping"}], "extent": [10573, 10609]}], "container": true}], "text": "Related"}], "title": ["Looping in geometry networks"]}